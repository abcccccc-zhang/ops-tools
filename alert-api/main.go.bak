package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/exec"

	"gopkg.in/yaml.v2"
)

// Alert struct to parse Alertmanager webhook data
type Alert struct {
	Alerts []struct {
		Labels map[string]string `json:"labels"`
	} `json:"alerts"`
}

// Condition struct to define alert matching conditions
type Condition struct {
	Alertname string            `yaml:"alertname"`
	Severity  string            `yaml:"severity"`
	Tags      map[string]string `yaml:"tags"`
	Action    string            `yaml:"action"`
}

// Action struct to define actions like executing a command or sending a webhook
type Action struct {
	Type    string            `yaml:"type"`
	Command string            `yaml:"command"`
	URL     string            `yaml:"url"`
	Method  string            `yaml:"method"`
	Headers map[string]string `yaml:"headers"`
	Body    map[string]string `yaml:"body"`
}

// LoadConfig loads conditions and actions from YAML files
func LoadConfig() ([]Condition, map[string]Action, error) {
	conditions := []Condition{}
	actions := make(map[string]Action)

	// Load conditions from file
	conditionFile, err := os.ReadFile("conditions.yml")
	if err != nil {
		log.Printf("Error reading conditions file: %v", err)
		return nil, nil, err
	}
	err = yaml.Unmarshal(conditionFile, &conditions)
	if err != nil {
		log.Printf("Error unmarshalling conditions file: %v", err)
		return nil, nil, err
	}

	// Load actions from file
	actionFile, err := os.ReadFile("actions.yml")
	if err != nil {
		log.Printf("Error reading actions file: %v", err)
		return nil, nil, err
	}
	err = yaml.Unmarshal(actionFile, &actions)
	if err != nil {
		log.Printf("Error unmarshalling actions file: %v", err)
		return nil, nil, err
	}

	log.Printf("Loaded %d conditions and %d actions", len(conditions), len(actions))
	return conditions, actions, nil
}

// ExecuteAction performs the action based on its type
func ExecuteAction(action Action) error {
	log.Printf("Executing action: %v", action)
	switch action.Type {
	case "command":
		// Run command (e.g., docker restart)
		cmd := exec.Command("sh", "-c", action.Command)
		log.Printf("Running command: %s", action.Command)
		return cmd.Run()
	case "webhook":
		// Send a webhook request
		client := &http.Client{}
		data, err := json.Marshal(action.Body)
		if err != nil {
			log.Printf("Error marshalling webhook body: %v", err)
			return err
		}
		req, err := http.NewRequest(action.Method, action.URL, bytes.NewBuffer(data))
		if err != nil {
			log.Printf("Error creating webhook request: %v", err)
			return err
		}
		for key, value := range action.Headers {
			req.Header.Set(key, value)
		}
		log.Printf("Sending webhook request to %s with method %s", action.URL, action.Method)
		resp, err := client.Do(req)
		if err != nil {
			log.Printf("Error sending webhook request: %v", err)
			return err
		}
		defer resp.Body.Close()
		log.Printf("Webhook response status: %s", resp.Status)
		return nil
	default:
		log.Printf("Unknown action type: %s", action.Type)
		return fmt.Errorf("unknown action type: %s", action.Type)
	}
}

// MatchAndExecute checks if the alert matches any condition and executes the corresponding action
func MatchAndExecute(alert Alert, conditions []Condition, actions map[string]Action) (string, error) {
	log.Printf("Matching alert: %v", alert)
	for _, condition := range conditions {
		if alert.Alerts[0].Labels["alertname"] == condition.Alertname &&
			alert.Alerts[0].Labels["severity"] == condition.Severity {
			log.Printf("Condition matched: %v", condition)
			for key, value := range condition.Tags {
				if alert.Alerts[0].Labels[key] != value {
					log.Printf("Tag mismatch: expected %s=%s, got %s=%s", key, value, key, alert.Alerts[0].Labels[key])
					return "No matching action", nil
				}
			}

			// If condition matched, execute the action
			action, found := actions[condition.Action]
			if !found {
				log.Printf("Action not found: %s", condition.Action)
				return "Action not found", nil
			}
			err := ExecuteAction(action)
			if err != nil {
				log.Printf("Failed to execute action: %v", err)
				return "Failed to execute action", err
			}
			log.Printf("Action executed successfully")
			return "Action executed successfully", nil
		}
	}
	log.Printf("No matching condition found for alert: %v", alert)
	return "No matching action found", nil
}

// AlertHandler is the API handler for receiving Alertmanager webhook data
func AlertHandler(w http.ResponseWriter, r *http.Request) {
	log.Println("Received a new alert")

	// Read and parse the incoming JSON payload
	var alert Alert
	err := json.NewDecoder(r.Body).Decode(&alert)
	if err != nil {
		log.Printf("Error decoding JSON: %v", err)
		http.Error(w, "Invalid JSON", http.StatusBadRequest)
		return
	}

	// Load the conditions and actions from YAML files
	conditions, actions, err := LoadConfig()
	if err != nil {
		log.Printf("Error loading config: %v", err)
		http.Error(w, fmt.Sprintf("Error loading config: %v", err), http.StatusInternalServerError)
		return
	}

	// Match the alert with conditions and execute corresponding action
	result, err := MatchAndExecute(alert, conditions, actions)
	if err != nil {
		log.Printf("Error executing action: %v", err)
		http.Error(w, fmt.Sprintf("Error executing action: %v", err), http.StatusInternalServerError)
		return
	}

	// Return the result
	log.Printf("Result: %s", result)
	w.WriteHeader(http.StatusOK)
	w.Write([]byte(result))
}

func main() {
	// Set up HTTP server to listen on port 5000
	log.Println("Starting server on :5000")
	http.HandleFunc("/alert", AlertHandler)
	log.Fatal(http.ListenAndServe(":5000", nil))
}
